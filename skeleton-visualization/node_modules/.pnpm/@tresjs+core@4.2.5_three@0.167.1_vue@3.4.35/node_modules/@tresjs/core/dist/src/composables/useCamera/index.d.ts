import { Camera } from 'three';
import { TresScene } from '../../types';
import { TresContext } from '../useTresContextProvider';

export declare const useCamera: ({ sizes }: Pick<TresContext, "sizes"> & {
    scene: TresScene;
}) => {
    camera: import('vue').ComputedRef<Camera | undefined>;
    cameras: import('vue').Ref<{
        readonly isCamera: true;
        readonly type: string | "Camera";
        layers: {
            mask: number;
            set: (layer: number) => void;
            enable: (layer: number) => void;
            enableAll: () => void;
            toggle: (layer: number) => void;
            disable: (layer: number) => void;
            disableAll: () => void;
            test: (layers: import('three').Layers) => boolean;
            isEnabled: (layer: number) => boolean;
        };
        matrixWorldInverse: {
            readonly isMatrix4: true;
            elements: number[];
            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
            identity: () => import('three').Matrix4;
            clone: () => import('three').Matrix4;
            copy: (m: import('three').Matrix4) => import('three').Matrix4;
            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
            multiplyScalar: (s: number) => import('three').Matrix4;
            determinant: () => number;
            transpose: () => import('three').Matrix4;
            setPosition: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            invert: () => import('three').Matrix4;
            scale: (v: import('three').Vector3) => import('three').Matrix4;
            getMaxScaleOnAxis: () => number;
            makeTranslation: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            makeRotationX: (theta: number) => import('three').Matrix4;
            makeRotationY: (theta: number) => import('three').Matrix4;
            makeRotationZ: (theta: number) => import('three').Matrix4;
            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            equals: (matrix: import('three').Matrix4) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            multiplyVector3: (v: any) => any;
            multiplyVector4: (v: any) => any;
            multiplyVector3Array: (array: number[]) => number[];
            rotateAxis: (v: any) => void;
            crossVector: (v: any) => void;
            flattenToArrayOffset: (array: number[], offset: number) => number[];
            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
        };
        projectionMatrix: {
            readonly isMatrix4: true;
            elements: number[];
            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
            identity: () => import('three').Matrix4;
            clone: () => import('three').Matrix4;
            copy: (m: import('three').Matrix4) => import('three').Matrix4;
            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
            multiplyScalar: (s: number) => import('three').Matrix4;
            determinant: () => number;
            transpose: () => import('three').Matrix4;
            setPosition: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            invert: () => import('three').Matrix4;
            scale: (v: import('three').Vector3) => import('three').Matrix4;
            getMaxScaleOnAxis: () => number;
            makeTranslation: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            makeRotationX: (theta: number) => import('three').Matrix4;
            makeRotationY: (theta: number) => import('three').Matrix4;
            makeRotationZ: (theta: number) => import('three').Matrix4;
            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            equals: (matrix: import('three').Matrix4) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            multiplyVector3: (v: any) => any;
            multiplyVector4: (v: any) => any;
            multiplyVector3Array: (array: number[]) => number[];
            rotateAxis: (v: any) => void;
            crossVector: (v: any) => void;
            flattenToArrayOffset: (array: number[], offset: number) => number[];
            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
        };
        projectionMatrixInverse: {
            readonly isMatrix4: true;
            elements: number[];
            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
            identity: () => import('three').Matrix4;
            clone: () => import('three').Matrix4;
            copy: (m: import('three').Matrix4) => import('three').Matrix4;
            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
            multiplyScalar: (s: number) => import('three').Matrix4;
            determinant: () => number;
            transpose: () => import('three').Matrix4;
            setPosition: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            invert: () => import('three').Matrix4;
            scale: (v: import('three').Vector3) => import('three').Matrix4;
            getMaxScaleOnAxis: () => number;
            makeTranslation: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            makeRotationX: (theta: number) => import('three').Matrix4;
            makeRotationY: (theta: number) => import('three').Matrix4;
            makeRotationZ: (theta: number) => import('three').Matrix4;
            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            equals: (matrix: import('three').Matrix4) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            multiplyVector3: (v: any) => any;
            multiplyVector4: (v: any) => any;
            multiplyVector3Array: (array: number[]) => number[];
            rotateAxis: (v: any) => void;
            crossVector: (v: any) => void;
            flattenToArrayOffset: (array: number[], offset: number) => number[];
            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
        };
        coordinateSystem: import('three').CoordinateSystem;
        viewport?: {
            x: number;
            y: number;
            z: number;
            w: number;
            width: number;
            height: number;
            readonly isVector4: true;
            set: (x: number, y: number, z: number, w: number) => import('three').Vector4;
            setScalar: (scalar: number) => import('three').Vector4;
            setX: (x: number) => import('three').Vector4;
            setY: (y: number) => import('three').Vector4;
            setZ: (z: number) => import('three').Vector4;
            setW: (w: number) => import('three').Vector4;
            setComponent: (index: number, value: number) => import('three').Vector4;
            getComponent: (index: number) => number;
            clone: () => import('three').Vector4;
            copy: (v: import('three').Vector4Like) => import('three').Vector4;
            add: (v: import('three').Vector4Like) => import('three').Vector4;
            addScalar: (scalar: number) => import('three').Vector4;
            addVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
            addScaledVector: (v: import('three').Vector4Like, s: number) => import('three').Vector4;
            sub: (v: import('three').Vector4Like) => import('three').Vector4;
            subScalar: (s: number) => import('three').Vector4;
            subVectors: (a: import('three').Vector4Like, b: import('three').Vector4Like) => import('three').Vector4;
            multiply: (v: import('three').Vector4Like) => import('three').Vector4;
            multiplyScalar: (s: number) => import('three').Vector4;
            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector4;
            divideScalar: (s: number) => import('three').Vector4;
            setAxisAngleFromQuaternion: (q: import('three').QuaternionLike) => import('three').Vector4;
            setAxisAngleFromRotationMatrix: (m: import('three').Matrix4) => import('three').Vector4;
            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector4;
            min: (v: import('three').Vector4Like) => import('three').Vector4;
            max: (v: import('three').Vector4Like) => import('three').Vector4;
            clamp: (min: import('three').Vector4Like, max: import('three').Vector4Like) => import('three').Vector4;
            clampScalar: (min: number, max: number) => import('three').Vector4;
            floor: () => import('three').Vector4;
            ceil: () => import('three').Vector4;
            round: () => import('three').Vector4;
            roundToZero: () => import('three').Vector4;
            negate: () => import('three').Vector4;
            dot: (v: import('three').Vector4Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => import('three').Vector4;
            setLength: (length: number) => import('three').Vector4;
            lerp: (v: import('three').Vector4Like, alpha: number) => import('three').Vector4;
            lerpVectors: (v1: import('three').Vector4Like, v2: import('three').Vector4Like, alpha: number) => import('three').Vector4;
            equals: (v: import('three').Vector4Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector4;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Vector4Tuple, offset?: 0): import('three').Vector4Tuple;
                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import('three').BufferAttribute, index: number) => import('three').Vector4;
            random: () => import('three').Vector4;
            [Symbol.iterator]: () => Iterator<number>;
        } | undefined;
        getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
        readonly isObject3D: true;
        readonly id: number;
        uuid: string;
        name: string;
        parent: {
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            readonly type: string | "Object3D";
            parent: any | null;
            children: any[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import('three').EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import('three').EulerOrder) => import('three').Euler;
                clone: () => import('three').Euler;
                copy: (euler: import('three').Euler) => import('three').Euler;
                setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
                setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
                setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder) => import('three').Euler;
                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                equals: (euler: import('three').Euler) => boolean;
                fromArray: (xyzo: [number, number, number, import('three').EulerOrder?, ...any[]]) => import('three').Euler;
                toArray: (array?: Array<number | string | undefined>, offset?: number) => Array<number | string | undefined>;
                _onChange: (callback: () => void) => import('three').Euler;
                [Symbol.iterator]: () => Generator<string | number, void>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                clone: () => import('three').Quaternion;
                copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                setFromEuler: (euler: import('three').Euler, update?: boolean) => import('three').Quaternion;
                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                angleTo: (q: import('three').Quaternion) => number;
                rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                identity: () => import('three').Quaternion;
                invert: () => import('three').Quaternion;
                conjugate: () => import('three').Quaternion;
                dot: (v: import('three').Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => import('three').Quaternion;
                multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                equals: (v: import('three').Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Quaternion;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                _onChange: (callback: () => void) => import('three').Quaternion;
                _onChangeCallback: () => void;
                random: () => import('three').Quaternion;
                [Symbol.iterator]: () => Generator<number, void>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number>;
            };
            readonly modelViewMatrix: {
                readonly isMatrix4: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            readonly normalMatrix: {
                readonly isMatrix3: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                identity: () => import('three').Matrix3;
                clone: () => import('three').Matrix3;
                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                multiplyScalar: (s: number) => import('three').Matrix3;
                determinant: () => number;
                invert: () => import('three').Matrix3;
                transpose: () => import('three').Matrix3;
                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                scale: (sx: number, sy: number) => import('three').Matrix3;
                makeTranslation: {
                    (v: import('three').Vector2): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                makeRotation: {
                    (theta: number): import('three').Matrix3;
                    (theta: number): import('three').Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                rotate: (theta: number) => import('three').Matrix3;
                translate: (tx: number, ty: number) => import('three').Matrix3;
                equals: (matrix: import('three').Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix3Tuple, offset?: 0): import('three').Matrix3Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                multiplyVector3: (vector: import('three').Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import('three').Matrix4, throwOnDegenerate?: boolean): import('three').Matrix3;
                    (matrix: import('three').Matrix): import('three').Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                readonly isMatrix4: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixWorld: {
                readonly isMatrix4: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import('three').Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import('three').InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                    getInterpolation: () => import('three').InterpolationModes;
                    createInterpolant: () => import('three').Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import('three').KeyframeTrack;
                    scale: (timeScale: number) => import('three').KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import('three').KeyframeTrack;
                    clone: () => import('three').KeyframeTrack;
                }[];
                blendMode: import('three').AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import('three').AnimationClip;
                trim: () => import('three').AnimationClip;
                validate: () => boolean;
                optimize: () => import('three').AnimationClip;
                clone: () => import('three').AnimationClip;
                toJSON: (clip: import('three').AnimationClip) => any;
            }[];
            userData: Record<string, any>;
            customDepthMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: undefined | {
                    [key: string]: any;
                };
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                hasEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): boolean;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                    dispose: {};
                }[T]) => void;
            } | undefined;
            customDistanceMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: undefined | {
                    [key: string]: any;
                };
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                hasEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): boolean;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                    dispose: {};
                }[T]) => void;
            } | undefined;
            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
            applyMatrix4: (matrix: import('three').Matrix4) => void;
            applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
            setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import('three').Euler) => void;
            setRotationFromMatrix: (m: import('three').Matrix4) => void;
            setRotationFromQuaternion: (q: import('three').Quaternion) => void;
            rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
            worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
            lookAt: {
                (vector: import('three').Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
            remove: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
            removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
            clear: () => import('three').Object3D<import('three').Object3DEventMap>;
            attach: (object: import('three').Object3D) => import('three').Object3D<import('three').Object3DEventMap>;
            getObjectById: (id: number) => import('three').Object3D | undefined;
            getObjectByName: (name: string) => import('three').Object3D | undefined;
            getObjectByProperty: (name: string, value: any) => import('three').Object3D | undefined;
            getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D[]) => import('three').Object3D[];
            getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
            getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
            getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
            getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
            raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection[]) => void;
            traverse: (callback: (object: import('three').Object3D) => any) => void;
            traverseVisible: (callback: (object: import('three').Object3D) => any) => void;
            traverseAncestors: (callback: (object: import('three').Object3D) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }) => any;
            clone: (recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
            copy: (object: import('three').Object3D, recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
            addEventListener: {
                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
            };
            hasEventListener: {
                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
            };
            removeEventListener: {
                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
            };
            dispatchEvent: <T extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T> & import('three').Object3DEventMap[T]) => void;
        } | null;
        children: {
            readonly isObject3D: true;
            readonly id: number;
            uuid: string;
            name: string;
            readonly type: string | "Object3D";
            parent: any | null;
            children: any[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number>;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number>;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import('three').EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import('three').EulerOrder) => import('three').Euler;
                clone: () => import('three').Euler;
                copy: (euler: import('three').Euler) => import('three').Euler;
                setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
                setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
                setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder) => import('three').Euler;
                reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
                equals: (euler: import('three').Euler) => boolean;
                fromArray: (xyzo: [number, number, number, import('three').EulerOrder?, ...any[]]) => import('three').Euler;
                toArray: (array?: Array<number | string | undefined>, offset?: number) => Array<number | string | undefined>;
                _onChange: (callback: () => void) => import('three').Euler;
                [Symbol.iterator]: () => Generator<string | number, void>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
                clone: () => import('three').Quaternion;
                copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
                setFromEuler: (euler: import('three').Euler, update?: boolean) => import('three').Quaternion;
                setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
                setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
                setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
                angleTo: (q: import('three').Quaternion) => number;
                rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
                identity: () => import('three').Quaternion;
                invert: () => import('three').Quaternion;
                conjugate: () => import('three').Quaternion;
                dot: (v: import('three').Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => import('three').Quaternion;
                multiply: (q: import('three').Quaternion) => import('three').Quaternion;
                premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
                multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
                slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
                equals: (v: import('three').Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Quaternion;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                toJSON: () => [number, number, number, number];
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
                _onChange: (callback: () => void) => import('three').Quaternion;
                _onChangeCallback: () => void;
                random: () => import('three').Quaternion;
                [Symbol.iterator]: () => Generator<number, void>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import('three').Vector3;
                setScalar: (scalar: number) => import('three').Vector3;
                setX: (x: number) => import('three').Vector3;
                setY: (y: number) => import('three').Vector3;
                setZ: (z: number) => import('three').Vector3;
                setComponent: (index: number, value: number) => import('three').Vector3;
                getComponent: (index: number) => number;
                clone: () => import('three').Vector3;
                copy: (v: import('three').Vector3Like) => import('three').Vector3;
                add: (v: import('three').Vector3Like) => import('three').Vector3;
                addScalar: (s: number) => import('three').Vector3;
                addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                sub: (a: import('three').Vector3Like) => import('three').Vector3;
                subScalar: (s: number) => import('three').Vector3;
                subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                multiplyScalar: (s: number) => import('three').Vector3;
                multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                project: (camera: Camera) => import('three').Vector3;
                unproject: (camera: Camera) => import('three').Vector3;
                transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                divide: (v: import('three').Vector3Like) => import('three').Vector3;
                divideScalar: (s: number) => import('three').Vector3;
                min: (v: import('three').Vector3Like) => import('three').Vector3;
                max: (v: import('three').Vector3Like) => import('three').Vector3;
                clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                clampScalar: (min: number, max: number) => import('three').Vector3;
                clampLength: (min: number, max: number) => import('three').Vector3;
                floor: () => import('three').Vector3;
                ceil: () => import('three').Vector3;
                round: () => import('three').Vector3;
                roundToZero: () => import('three').Vector3;
                negate: () => import('three').Vector3;
                dot: (v: import('three').Vector3Like) => number;
                lengthSq: () => number;
                length: () => number;
                manhattanLength: () => number;
                normalize: () => import('three').Vector3;
                setLength: (l: number) => import('three').Vector3;
                lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                cross: (a: import('three').Vector3Like) => import('three').Vector3;
                crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                angleTo: (v: import('three').Vector3) => number;
                distanceTo: (v: import('three').Vector3Like) => number;
                distanceToSquared: (v: import('three').Vector3Like) => number;
                manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                setFromColor: (color: import('three').RGB) => import('three').Vector3;
                equals: (v: import('three').Vector3Like) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                random: () => import('three').Vector3;
                randomDirection: () => import('three').Vector3;
                [Symbol.iterator]: () => Iterator<number>;
            };
            readonly modelViewMatrix: {
                readonly isMatrix4: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            readonly normalMatrix: {
                readonly isMatrix3: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
                identity: () => import('three').Matrix3;
                clone: () => import('three').Matrix3;
                copy: (m: import('three').Matrix3) => import('three').Matrix3;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
                setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
                multiplyScalar: (s: number) => import('three').Matrix3;
                determinant: () => number;
                invert: () => import('three').Matrix3;
                transpose: () => import('three').Matrix3;
                getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
                transposeIntoArray: (r: number[]) => import('three').Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
                scale: (sx: number, sy: number) => import('three').Matrix3;
                makeTranslation: {
                    (v: import('three').Vector2): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                makeRotation: {
                    (theta: number): import('three').Matrix3;
                    (theta: number): import('three').Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import('three').Matrix3;
                    (x: number, y: number): import('three').Matrix3;
                };
                rotate: (theta: number) => import('three').Matrix3;
                translate: (tx: number, ty: number) => import('three').Matrix3;
                equals: (matrix: import('three').Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix3;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix3Tuple, offset?: 0): import('three').Matrix3Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                multiply: (m: import('three').Matrix3) => import('three').Matrix3;
                premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
                multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
                multiplyVector3: (vector: import('three').Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import('three').Matrix4, throwOnDegenerate?: boolean): import('three').Matrix3;
                    (matrix: import('three').Matrix): import('three').Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                readonly isMatrix4: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixWorld: {
                readonly isMatrix4: true;
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
                identity: () => import('three').Matrix4;
                clone: () => import('three').Matrix4;
                copy: (m: import('three').Matrix4) => import('three').Matrix4;
                copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
                extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
                makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
                makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
                multiply: (m: import('three').Matrix4) => import('three').Matrix4;
                premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
                multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
                multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
                multiplyScalar: (s: number) => import('three').Matrix4;
                determinant: () => number;
                transpose: () => import('three').Matrix4;
                setPosition: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                invert: () => import('three').Matrix4;
                scale: (v: import('three').Vector3) => import('three').Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: {
                    (v: import('three').Vector3): import('three').Matrix4;
                    (x: number, y: number, z: number): import('three').Matrix4;
                };
                makeRotationX: (theta: number) => import('three').Matrix4;
                makeRotationY: (theta: number) => import('three').Matrix4;
                makeRotationZ: (theta: number) => import('three').Matrix4;
                makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
                makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
                compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
                makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
                equals: (matrix: import('three').Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                    (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
                extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
                setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: {
                mask: number;
                set: (layer: number) => void;
                enable: (layer: number) => void;
                enableAll: () => void;
                toggle: (layer: number) => void;
                disable: (layer: number) => void;
                disableAll: () => void;
                test: (layers: import('three').Layers) => boolean;
                isEnabled: (layer: number) => boolean;
            };
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number, end?: number) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number) => number;
                        join: (separator?: string) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number) => void;
                        slice: (start?: number, end?: number) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number, end?: number) => Float32Array;
                        toLocaleString: {
                            (): string;
                            (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                        };
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number) => boolean;
                        at: (index: number) => number | undefined;
                        findLast: {
                            <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                            (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                        };
                        findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                        toReversed: () => Float32Array;
                        toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        with: (index: number, value: number) => Float32Array;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import('three').InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                    setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                    getInterpolation: () => import('three').InterpolationModes;
                    createInterpolant: () => import('three').Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import('three').KeyframeTrack;
                    scale: (timeScale: number) => import('three').KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import('three').KeyframeTrack;
                    clone: () => import('three').KeyframeTrack;
                }[];
                blendMode: import('three').AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import('three').AnimationClip;
                trim: () => import('three').AnimationClip;
                validate: () => boolean;
                optimize: () => import('three').AnimationClip;
                clone: () => import('three').AnimationClip;
                toJSON: (clip: import('three').AnimationClip) => any;
            }[];
            userData: Record<string, any>;
            customDepthMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: undefined | {
                    [key: string]: any;
                };
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                hasEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): boolean;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                    dispose: {};
                }[T]) => void;
            } | undefined;
            customDistanceMaterial?: {
                readonly isMaterial: true;
                alphaHash: boolean;
                alphaToCoverage: boolean;
                blendAlpha: number;
                blendColor: {
                    readonly isColor: true;
                    r: number;
                    g: number;
                    b: number;
                    set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                    setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                    setScalar: (scalar: number) => import('three').Color;
                    setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                    clone: () => import('three').Color;
                    copy: (color: import('three').Color) => import('three').Color;
                    copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                    copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                    convertSRGBToLinear: () => import('three').Color;
                    convertLinearToSRGB: () => import('three').Color;
                    getHex: (colorSpace?: import('three').ColorSpace) => number;
                    getHexString: (colorSpace?: import('three').ColorSpace) => string;
                    getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
                    getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
                    getStyle: (colorSpace?: import('three').ColorSpace) => string;
                    offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                    add: (color: import('three').Color) => import('three').Color;
                    addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                    addScalar: (s: number) => import('three').Color;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                    sub: (color: import('three').Color) => import('three').Color;
                    multiply: (color: import('three').Color) => import('three').Color;
                    multiplyScalar: (s: number) => import('three').Color;
                    lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                    lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                    lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                    equals: (color: import('three').Color) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    toJSON: () => number;
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                    [Symbol.iterator]: () => Generator<number, void>;
                };
                blendDst: import('three').BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import('three').BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import('three').Blending;
                blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: {
                    normal: {
                        x: number;
                        y: number;
                        z: number;
                        readonly isVector3: true;
                        set: (x: number, y: number, z: number) => import('three').Vector3;
                        setScalar: (scalar: number) => import('three').Vector3;
                        setX: (x: number) => import('three').Vector3;
                        setY: (y: number) => import('three').Vector3;
                        setZ: (z: number) => import('three').Vector3;
                        setComponent: (index: number, value: number) => import('three').Vector3;
                        getComponent: (index: number) => number;
                        clone: () => import('three').Vector3;
                        copy: (v: import('three').Vector3Like) => import('three').Vector3;
                        add: (v: import('three').Vector3Like) => import('three').Vector3;
                        addScalar: (s: number) => import('three').Vector3;
                        addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                        sub: (a: import('three').Vector3Like) => import('three').Vector3;
                        subScalar: (s: number) => import('three').Vector3;
                        subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                        multiplyScalar: (s: number) => import('three').Vector3;
                        multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                        applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                        applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                        applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                        applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                        applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                        project: (camera: Camera) => import('three').Vector3;
                        unproject: (camera: Camera) => import('three').Vector3;
                        transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                        divide: (v: import('three').Vector3Like) => import('three').Vector3;
                        divideScalar: (s: number) => import('three').Vector3;
                        min: (v: import('three').Vector3Like) => import('three').Vector3;
                        max: (v: import('three').Vector3Like) => import('three').Vector3;
                        clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                        clampScalar: (min: number, max: number) => import('three').Vector3;
                        clampLength: (min: number, max: number) => import('three').Vector3;
                        floor: () => import('three').Vector3;
                        ceil: () => import('three').Vector3;
                        round: () => import('three').Vector3;
                        roundToZero: () => import('three').Vector3;
                        negate: () => import('three').Vector3;
                        dot: (v: import('three').Vector3Like) => number;
                        lengthSq: () => number;
                        length: () => number;
                        manhattanLength: () => number;
                        normalize: () => import('three').Vector3;
                        setLength: (l: number) => import('three').Vector3;
                        lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                        cross: (a: import('three').Vector3Like) => import('three').Vector3;
                        crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                        projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                        projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                        reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                        angleTo: (v: import('three').Vector3) => number;
                        distanceTo: (v: import('three').Vector3Like) => number;
                        distanceToSquared: (v: import('three').Vector3Like) => number;
                        manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                        setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                        setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                        setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                        setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                        setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                        setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                        setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                        setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                        setFromColor: (color: import('three').RGB) => import('three').Vector3;
                        equals: (v: import('three').Vector3Like) => boolean;
                        fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                        toArray: {
                            (array?: number[], offset?: number): number[];
                            (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                            (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                        };
                        fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                        random: () => import('three').Vector3;
                        randomDirection: () => import('three').Vector3;
                        [Symbol.iterator]: () => Iterator<number>;
                    };
                    constant: number;
                    readonly isPlane: true;
                    set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                    setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                    setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                    setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                    clone: () => import('three').Plane;
                    copy: (plane: import('three').Plane) => import('three').Plane;
                    normalize: () => import('three').Plane;
                    negate: () => import('three').Plane;
                    distanceToPoint: (point: import('three').Vector3) => number;
                    distanceToSphere: (sphere: import('three').Sphere) => number;
                    projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                    intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                    intersectsLine: (line: import('three').Line3) => boolean;
                    intersectsBox: (box: import('three').Box3) => boolean;
                    intersectsSphere: (sphere: import('three').Sphere) => boolean;
                    coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                    applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
                    translate: (offset: import('three').Vector3) => import('three').Plane;
                    equals: (plane: import('three').Plane) => boolean;
                    isIntersectionLine: (l: any) => any;
                }[] | null;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: undefined | {
                    [key: string]: any;
                };
                depthFunc: import('three').DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import('three').StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import('three').StencilOp;
                stencilZFail: import('three').StencilOp;
                stencilZPass: import('three').StencilOp;
                name: string;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import('three').Side;
                shadowSide: import('three').Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: Record<string, any>;
                version: number;
                alphaTest: number;
                onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import('three').MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                clone: () => import('three').Material;
                copy: (material: import('three').Material) => import('three').Material;
                dispose: () => void;
                needsUpdate: boolean;
                onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
                onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
                addEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                hasEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): boolean;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
                };
                removeEventListener: {
                    <T extends "dispose">(type: T, listener: import('three').EventListener<{
                        dispose: {};
                    }[T], T, import('three').Material>): void;
                    <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
                };
                dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                    dispose: {};
                }[T]) => void;
            } | undefined;
            onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
            onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
            onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
            applyMatrix4: (matrix: import('three').Matrix4) => void;
            applyQuaternion: (quaternion: import('three').Quaternion) => import('three').Object3D<import('three').Object3DEventMap>;
            setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import('three').Euler) => void;
            setRotationFromMatrix: (m: import('three').Matrix4) => void;
            setRotationFromQuaternion: (q: import('three').Quaternion) => void;
            rotateOnAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateX: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateY: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            rotateZ: (angle: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateOnAxis: (axis: import('three').Vector3, distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateX: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateY: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            translateZ: (distance: number) => import('three').Object3D<import('three').Object3DEventMap>;
            localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
            worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
            lookAt: {
                (vector: import('three').Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
            remove: (...object: import('three').Object3D[]) => import('three').Object3D<import('three').Object3DEventMap>;
            removeFromParent: () => import('three').Object3D<import('three').Object3DEventMap>;
            clear: () => import('three').Object3D<import('three').Object3DEventMap>;
            attach: (object: import('three').Object3D) => import('three').Object3D<import('three').Object3DEventMap>;
            getObjectById: (id: number) => import('three').Object3D | undefined;
            getObjectByName: (name: string) => import('three').Object3D | undefined;
            getObjectByProperty: (name: string, value: any) => import('three').Object3D | undefined;
            getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D[]) => import('three').Object3D[];
            getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
            getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
            getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
            getWorldDirection: (target: import('three').Vector3) => import('three').Vector3;
            raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection[]) => void;
            traverse: (callback: (object: import('three').Object3D) => any) => void;
            traverseVisible: (callback: (object: import('three').Object3D) => any) => void;
            traverseAncestors: (callback: (object: import('three').Object3D) => any) => void;
            updateMatrix: () => void;
            updateMatrixWorld: (force?: boolean) => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            }) => any;
            clone: (recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
            copy: (object: import('three').Object3D, recursive?: boolean) => import('three').Object3D<import('three').Object3DEventMap>;
            addEventListener: {
                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
            };
            hasEventListener: {
                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): boolean;
            };
            removeEventListener: {
                <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, import('three').Object3D<import('three').Object3DEventMap>>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Object3D<import('three').Object3DEventMap>>): void;
            };
            dispatchEvent: <T extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T> & import('three').Object3DEventMap[T]) => void;
        }[];
        up: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import('three').Vector3;
            setScalar: (scalar: number) => import('three').Vector3;
            setX: (x: number) => import('three').Vector3;
            setY: (y: number) => import('three').Vector3;
            setZ: (z: number) => import('three').Vector3;
            setComponent: (index: number, value: number) => import('three').Vector3;
            getComponent: (index: number) => number;
            clone: () => import('three').Vector3;
            copy: (v: import('three').Vector3Like) => import('three').Vector3;
            add: (v: import('three').Vector3Like) => import('three').Vector3;
            addScalar: (s: number) => import('three').Vector3;
            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
            sub: (a: import('three').Vector3Like) => import('three').Vector3;
            subScalar: (s: number) => import('three').Vector3;
            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
            multiplyScalar: (s: number) => import('three').Vector3;
            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
            project: (camera: Camera) => import('three').Vector3;
            unproject: (camera: Camera) => import('three').Vector3;
            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
            divide: (v: import('three').Vector3Like) => import('three').Vector3;
            divideScalar: (s: number) => import('three').Vector3;
            min: (v: import('three').Vector3Like) => import('three').Vector3;
            max: (v: import('three').Vector3Like) => import('three').Vector3;
            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
            clampScalar: (min: number, max: number) => import('three').Vector3;
            clampLength: (min: number, max: number) => import('three').Vector3;
            floor: () => import('three').Vector3;
            ceil: () => import('three').Vector3;
            round: () => import('three').Vector3;
            roundToZero: () => import('three').Vector3;
            negate: () => import('three').Vector3;
            dot: (v: import('three').Vector3Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => import('three').Vector3;
            setLength: (l: number) => import('three').Vector3;
            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            cross: (a: import('three').Vector3Like) => import('three').Vector3;
            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
            angleTo: (v: import('three').Vector3) => number;
            distanceTo: (v: import('three').Vector3Like) => number;
            distanceToSquared: (v: import('three').Vector3Like) => number;
            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
            setFromColor: (color: import('three').RGB) => import('three').Vector3;
            equals: (v: import('three').Vector3Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
            random: () => import('three').Vector3;
            randomDirection: () => import('three').Vector3;
            [Symbol.iterator]: () => Iterator<number>;
        };
        readonly position: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import('three').Vector3;
            setScalar: (scalar: number) => import('three').Vector3;
            setX: (x: number) => import('three').Vector3;
            setY: (y: number) => import('three').Vector3;
            setZ: (z: number) => import('three').Vector3;
            setComponent: (index: number, value: number) => import('three').Vector3;
            getComponent: (index: number) => number;
            clone: () => import('three').Vector3;
            copy: (v: import('three').Vector3Like) => import('three').Vector3;
            add: (v: import('three').Vector3Like) => import('three').Vector3;
            addScalar: (s: number) => import('three').Vector3;
            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
            sub: (a: import('three').Vector3Like) => import('three').Vector3;
            subScalar: (s: number) => import('three').Vector3;
            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
            multiplyScalar: (s: number) => import('three').Vector3;
            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
            project: (camera: Camera) => import('three').Vector3;
            unproject: (camera: Camera) => import('three').Vector3;
            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
            divide: (v: import('three').Vector3Like) => import('three').Vector3;
            divideScalar: (s: number) => import('three').Vector3;
            min: (v: import('three').Vector3Like) => import('three').Vector3;
            max: (v: import('three').Vector3Like) => import('three').Vector3;
            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
            clampScalar: (min: number, max: number) => import('three').Vector3;
            clampLength: (min: number, max: number) => import('three').Vector3;
            floor: () => import('three').Vector3;
            ceil: () => import('three').Vector3;
            round: () => import('three').Vector3;
            roundToZero: () => import('three').Vector3;
            negate: () => import('three').Vector3;
            dot: (v: import('three').Vector3Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => import('three').Vector3;
            setLength: (l: number) => import('three').Vector3;
            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            cross: (a: import('three').Vector3Like) => import('three').Vector3;
            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
            angleTo: (v: import('three').Vector3) => number;
            distanceTo: (v: import('three').Vector3Like) => number;
            distanceToSquared: (v: import('three').Vector3Like) => number;
            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
            setFromColor: (color: import('three').RGB) => import('three').Vector3;
            equals: (v: import('three').Vector3Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
            random: () => import('three').Vector3;
            randomDirection: () => import('three').Vector3;
            [Symbol.iterator]: () => Iterator<number>;
        };
        readonly rotation: {
            x: number;
            y: number;
            z: number;
            order: import('three').EulerOrder;
            readonly isEuler: true;
            _onChangeCallback: () => void;
            set: (x: number, y: number, z: number, order?: import('three').EulerOrder) => import('three').Euler;
            clone: () => import('three').Euler;
            copy: (euler: import('three').Euler) => import('three').Euler;
            setFromRotationMatrix: (m: import('three').Matrix4, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
            setFromQuaternion: (q: import('three').Quaternion, order?: import('three').EulerOrder, update?: boolean) => import('three').Euler;
            setFromVector3: (v: import('three').Vector3, order?: import('three').EulerOrder) => import('three').Euler;
            reorder: (newOrder: import('three').EulerOrder) => import('three').Euler;
            equals: (euler: import('three').Euler) => boolean;
            fromArray: (xyzo: [number, number, number, import('three').EulerOrder?, ...any[]]) => import('three').Euler;
            toArray: (array?: Array<number | string | undefined>, offset?: number) => Array<number | string | undefined>;
            _onChange: (callback: () => void) => import('three').Euler;
            [Symbol.iterator]: () => Generator<string | number, void>;
        };
        readonly quaternion: {
            x: number;
            y: number;
            z: number;
            w: number;
            readonly isQuaternion: true;
            set: (x: number, y: number, z: number, w: number) => import('three').Quaternion;
            clone: () => import('three').Quaternion;
            copy: (q: import('three').QuaternionLike) => import('three').Quaternion;
            setFromEuler: (euler: import('three').Euler, update?: boolean) => import('three').Quaternion;
            setFromAxisAngle: (axis: import('three').Vector3Like, angle: number) => import('three').Quaternion;
            setFromRotationMatrix: (m: import('three').Matrix4) => import('three').Quaternion;
            setFromUnitVectors: (vFrom: import('three').Vector3, vTo: import('three').Vector3Like) => import('three').Quaternion;
            angleTo: (q: import('three').Quaternion) => number;
            rotateTowards: (q: import('three').Quaternion, step: number) => import('three').Quaternion;
            identity: () => import('three').Quaternion;
            invert: () => import('three').Quaternion;
            conjugate: () => import('three').Quaternion;
            dot: (v: import('three').Quaternion) => number;
            lengthSq: () => number;
            length: () => number;
            normalize: () => import('three').Quaternion;
            multiply: (q: import('three').Quaternion) => import('three').Quaternion;
            premultiply: (q: import('three').Quaternion) => import('three').Quaternion;
            multiplyQuaternions: (a: import('three').Quaternion, b: import('three').Quaternion) => import('three').Quaternion;
            slerp: (qb: import('three').Quaternion, t: number) => import('three').Quaternion;
            slerpQuaternions: (qa: import('three').Quaternion, qb: import('three').Quaternion, t: number) => import('three').Quaternion;
            equals: (v: import('three').Quaternion) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Quaternion;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            toJSON: () => [number, number, number, number];
            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Quaternion;
            _onChange: (callback: () => void) => import('three').Quaternion;
            _onChangeCallback: () => void;
            random: () => import('three').Quaternion;
            [Symbol.iterator]: () => Generator<number, void>;
        };
        readonly scale: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import('three').Vector3;
            setScalar: (scalar: number) => import('three').Vector3;
            setX: (x: number) => import('three').Vector3;
            setY: (y: number) => import('three').Vector3;
            setZ: (z: number) => import('three').Vector3;
            setComponent: (index: number, value: number) => import('three').Vector3;
            getComponent: (index: number) => number;
            clone: () => import('three').Vector3;
            copy: (v: import('three').Vector3Like) => import('three').Vector3;
            add: (v: import('three').Vector3Like) => import('three').Vector3;
            addScalar: (s: number) => import('three').Vector3;
            addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
            sub: (a: import('three').Vector3Like) => import('three').Vector3;
            subScalar: (s: number) => import('three').Vector3;
            subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            multiply: (v: import('three').Vector3Like) => import('three').Vector3;
            multiplyScalar: (s: number) => import('three').Vector3;
            multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            applyEuler: (euler: import('three').Euler) => import('three').Vector3;
            applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
            applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
            applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
            applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
            applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
            project: (camera: Camera) => import('three').Vector3;
            unproject: (camera: Camera) => import('three').Vector3;
            transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
            divide: (v: import('three').Vector3Like) => import('three').Vector3;
            divideScalar: (s: number) => import('three').Vector3;
            min: (v: import('three').Vector3Like) => import('three').Vector3;
            max: (v: import('three').Vector3Like) => import('three').Vector3;
            clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
            clampScalar: (min: number, max: number) => import('three').Vector3;
            clampLength: (min: number, max: number) => import('three').Vector3;
            floor: () => import('three').Vector3;
            ceil: () => import('three').Vector3;
            round: () => import('three').Vector3;
            roundToZero: () => import('three').Vector3;
            negate: () => import('three').Vector3;
            dot: (v: import('three').Vector3Like) => number;
            lengthSq: () => number;
            length: () => number;
            manhattanLength: () => number;
            normalize: () => import('three').Vector3;
            setLength: (l: number) => import('three').Vector3;
            lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
            cross: (a: import('three').Vector3Like) => import('three').Vector3;
            crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
            projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
            projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
            reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
            angleTo: (v: import('three').Vector3) => number;
            distanceTo: (v: import('three').Vector3Like) => number;
            distanceToSquared: (v: import('three').Vector3Like) => number;
            manhattanDistanceTo: (v: import('three').Vector3Like) => number;
            setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
            setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
            setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
            setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
            setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
            setFromEuler: (e: import('three').Euler) => import('three').Vector3;
            setFromColor: (color: import('three').RGB) => import('three').Vector3;
            equals: (v: import('three').Vector3Like) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
            random: () => import('three').Vector3;
            randomDirection: () => import('three').Vector3;
            [Symbol.iterator]: () => Iterator<number>;
        };
        readonly modelViewMatrix: {
            readonly isMatrix4: true;
            elements: number[];
            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
            identity: () => import('three').Matrix4;
            clone: () => import('three').Matrix4;
            copy: (m: import('three').Matrix4) => import('three').Matrix4;
            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
            multiplyScalar: (s: number) => import('three').Matrix4;
            determinant: () => number;
            transpose: () => import('three').Matrix4;
            setPosition: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            invert: () => import('three').Matrix4;
            scale: (v: import('three').Vector3) => import('three').Matrix4;
            getMaxScaleOnAxis: () => number;
            makeTranslation: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            makeRotationX: (theta: number) => import('three').Matrix4;
            makeRotationY: (theta: number) => import('three').Matrix4;
            makeRotationZ: (theta: number) => import('three').Matrix4;
            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            equals: (matrix: import('three').Matrix4) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            multiplyVector3: (v: any) => any;
            multiplyVector4: (v: any) => any;
            multiplyVector3Array: (array: number[]) => number[];
            rotateAxis: (v: any) => void;
            crossVector: (v: any) => void;
            flattenToArrayOffset: (array: number[], offset: number) => number[];
            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
        };
        readonly normalMatrix: {
            readonly isMatrix3: true;
            elements: number[];
            set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import('three').Matrix3;
            identity: () => import('three').Matrix3;
            clone: () => import('three').Matrix3;
            copy: (m: import('three').Matrix3) => import('three').Matrix3;
            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix3;
            setFromMatrix4: (m: import('three').Matrix4) => import('three').Matrix3;
            multiplyScalar: (s: number) => import('three').Matrix3;
            determinant: () => number;
            invert: () => import('three').Matrix3;
            transpose: () => import('three').Matrix3;
            getNormalMatrix: (matrix4: import('three').Matrix4) => import('three').Matrix3;
            transposeIntoArray: (r: number[]) => import('three').Matrix3;
            setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import('three').Matrix3;
            scale: (sx: number, sy: number) => import('three').Matrix3;
            makeTranslation: {
                (v: import('three').Vector2): import('three').Matrix3;
                (x: number, y: number): import('three').Matrix3;
            };
            makeRotation: {
                (theta: number): import('three').Matrix3;
                (theta: number): import('three').Matrix3;
            };
            makeScale: {
                (x: number, y: number): import('three').Matrix3;
                (x: number, y: number): import('three').Matrix3;
            };
            rotate: (theta: number) => import('three').Matrix3;
            translate: (tx: number, ty: number) => import('three').Matrix3;
            equals: (matrix: import('three').Matrix3) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix3;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Matrix3Tuple, offset?: 0): import('three').Matrix3Tuple;
                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            multiply: (m: import('three').Matrix3) => import('three').Matrix3;
            premultiply: (m: import('three').Matrix3) => import('three').Matrix3;
            multiplyMatrices: (a: import('three').Matrix3, b: import('three').Matrix3) => import('three').Matrix3;
            multiplyVector3: (vector: import('three').Vector3) => any;
            multiplyVector3Array: (a: any) => any;
            getInverse: {
                (matrix: import('three').Matrix4, throwOnDegenerate?: boolean): import('three').Matrix3;
                (matrix: import('three').Matrix): import('three').Matrix;
            };
            flattenToArrayOffset: (array: number[], offset: number) => number[];
        };
        matrix: {
            readonly isMatrix4: true;
            elements: number[];
            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
            identity: () => import('three').Matrix4;
            clone: () => import('three').Matrix4;
            copy: (m: import('three').Matrix4) => import('three').Matrix4;
            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
            multiplyScalar: (s: number) => import('three').Matrix4;
            determinant: () => number;
            transpose: () => import('three').Matrix4;
            setPosition: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            invert: () => import('three').Matrix4;
            scale: (v: import('three').Vector3) => import('three').Matrix4;
            getMaxScaleOnAxis: () => number;
            makeTranslation: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            makeRotationX: (theta: number) => import('three').Matrix4;
            makeRotationY: (theta: number) => import('three').Matrix4;
            makeRotationZ: (theta: number) => import('three').Matrix4;
            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            equals: (matrix: import('three').Matrix4) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            multiplyVector3: (v: any) => any;
            multiplyVector4: (v: any) => any;
            multiplyVector3Array: (array: number[]) => number[];
            rotateAxis: (v: any) => void;
            crossVector: (v: any) => void;
            flattenToArrayOffset: (array: number[], offset: number) => number[];
            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
        };
        matrixWorld: {
            readonly isMatrix4: true;
            elements: number[];
            set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import('three').Matrix4;
            identity: () => import('three').Matrix4;
            clone: () => import('three').Matrix4;
            copy: (m: import('three').Matrix4) => import('three').Matrix4;
            copyPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            extractBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            makeBasis: (xAxis: import('three').Vector3, yAxis: import('three').Vector3, zAxis: import('three').Vector3) => import('three').Matrix4;
            extractRotation: (m: import('three').Matrix4) => import('three').Matrix4;
            makeRotationFromEuler: (euler: import('three').Euler) => import('three').Matrix4;
            makeRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            lookAt: (eye: import('three').Vector3, target: import('three').Vector3, up: import('three').Vector3) => import('three').Matrix4;
            multiply: (m: import('three').Matrix4) => import('three').Matrix4;
            premultiply: (m: import('three').Matrix4) => import('three').Matrix4;
            multiplyMatrices: (a: import('three').Matrix4, b: import('three').Matrix4) => import('three').Matrix4;
            multiplyToArray: (a: import('three').Matrix4, b: import('three').Matrix4, r: number[]) => import('three').Matrix4;
            multiplyScalar: (s: number) => import('three').Matrix4;
            determinant: () => number;
            transpose: () => import('three').Matrix4;
            setPosition: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            invert: () => import('three').Matrix4;
            scale: (v: import('three').Vector3) => import('three').Matrix4;
            getMaxScaleOnAxis: () => number;
            makeTranslation: {
                (v: import('three').Vector3): import('three').Matrix4;
                (x: number, y: number, z: number): import('three').Matrix4;
            };
            makeRotationX: (theta: number) => import('three').Matrix4;
            makeRotationY: (theta: number) => import('three').Matrix4;
            makeRotationZ: (theta: number) => import('three').Matrix4;
            makeRotationAxis: (axis: import('three').Vector3, angle: number) => import('three').Matrix4;
            makeScale: (x: number, y: number, z: number) => import('three').Matrix4;
            makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import('three').Matrix4;
            compose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            decompose: (translation: import('three').Vector3, rotation: import('three').Quaternion, scale: import('three').Vector3) => import('three').Matrix4;
            makePerspective: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number, coordinateSystem?: import('three').CoordinateSystem) => import('three').Matrix4;
            equals: (matrix: import('three').Matrix4) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Matrix4;
            toArray: {
                (array?: number[], offset?: number): number[];
                (array?: import('three').Matrix4Tuple, offset?: 0): import('three').Matrix4Tuple;
                (array?: ArrayLike<number>, offset?: number): ArrayLike<number>;
            };
            setFromMatrix3: (m: import('three').Matrix3) => import('three').Matrix4;
            extractPosition: (m: import('three').Matrix4) => import('three').Matrix4;
            setRotationFromQuaternion: (q: import('three').Quaternion) => import('three').Matrix4;
            multiplyVector3: (v: any) => any;
            multiplyVector4: (v: any) => any;
            multiplyVector3Array: (array: number[]) => number[];
            rotateAxis: (v: any) => void;
            crossVector: (v: any) => void;
            flattenToArrayOffset: (array: number[], offset: number) => number[];
            getInverse: (matrix: import('three').Matrix) => import('three').Matrix;
        };
        matrixAutoUpdate: boolean;
        matrixWorldAutoUpdate: boolean;
        matrixWorldNeedsUpdate: boolean;
        visible: boolean;
        castShadow: boolean;
        receiveShadow: boolean;
        frustumCulled: boolean;
        renderOrder: number;
        animations: {
            name: string;
            tracks: {
                name: string;
                times: {
                    [x: number]: number;
                    readonly BYTES_PER_ELEMENT: number;
                    readonly buffer: {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => ArrayBuffer;
                        readonly [Symbol.toStringTag]: string;
                    } | {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                        readonly [Symbol.species]: SharedArrayBuffer;
                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                    };
                    readonly byteLength: number;
                    readonly byteOffset: number;
                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                    every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    fill: (value: number, start?: number, end?: number) => Float32Array;
                    filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                    find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                    findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                    forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                    indexOf: (searchElement: number, fromIndex?: number) => number;
                    join: (separator?: string) => string;
                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                    readonly length: number;
                    map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                    reduce: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reduceRight: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reverse: () => Float32Array;
                    set: (array: ArrayLike<number>, offset?: number) => void;
                    slice: (start?: number, end?: number) => Float32Array;
                    some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    subarray: (begin?: number, end?: number) => Float32Array;
                    toLocaleString: {
                        (): string;
                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                    };
                    toString: () => string;
                    valueOf: () => Float32Array;
                    entries: () => IterableIterator<[number, number]>;
                    keys: () => IterableIterator<number>;
                    values: () => IterableIterator<number>;
                    includes: (searchElement: number, fromIndex?: number) => boolean;
                    at: (index: number) => number | undefined;
                    findLast: {
                        <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                        (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                    };
                    findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                    toReversed: () => Float32Array;
                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    with: (index: number, value: number) => Float32Array;
                    [Symbol.iterator]: () => IterableIterator<number>;
                    readonly [Symbol.toStringTag]: "Float32Array";
                };
                values: {
                    [x: number]: number;
                    readonly BYTES_PER_ELEMENT: number;
                    readonly buffer: {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => ArrayBuffer;
                        readonly [Symbol.toStringTag]: string;
                    } | {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                        readonly [Symbol.species]: SharedArrayBuffer;
                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                    };
                    readonly byteLength: number;
                    readonly byteOffset: number;
                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                    every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    fill: (value: number, start?: number, end?: number) => Float32Array;
                    filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                    find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                    findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                    forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                    indexOf: (searchElement: number, fromIndex?: number) => number;
                    join: (separator?: string) => string;
                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                    readonly length: number;
                    map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                    reduce: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reduceRight: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reverse: () => Float32Array;
                    set: (array: ArrayLike<number>, offset?: number) => void;
                    slice: (start?: number, end?: number) => Float32Array;
                    some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    subarray: (begin?: number, end?: number) => Float32Array;
                    toLocaleString: {
                        (): string;
                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                    };
                    toString: () => string;
                    valueOf: () => Float32Array;
                    entries: () => IterableIterator<[number, number]>;
                    keys: () => IterableIterator<number>;
                    values: () => IterableIterator<number>;
                    includes: (searchElement: number, fromIndex?: number) => boolean;
                    at: (index: number) => number | undefined;
                    findLast: {
                        <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                        (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                    };
                    findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                    toReversed: () => Float32Array;
                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    with: (index: number, value: number) => Float32Array;
                    [Symbol.iterator]: () => IterableIterator<number>;
                    readonly [Symbol.toStringTag]: "Float32Array";
                };
                ValueTypeName: string;
                TimeBufferType: {
                    [x: number]: number;
                    readonly BYTES_PER_ELEMENT: number;
                    readonly buffer: {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => ArrayBuffer;
                        readonly [Symbol.toStringTag]: string;
                    } | {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                        readonly [Symbol.species]: SharedArrayBuffer;
                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                    };
                    readonly byteLength: number;
                    readonly byteOffset: number;
                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                    every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    fill: (value: number, start?: number, end?: number) => Float32Array;
                    filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                    find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                    findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                    forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                    indexOf: (searchElement: number, fromIndex?: number) => number;
                    join: (separator?: string) => string;
                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                    readonly length: number;
                    map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                    reduce: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reduceRight: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reverse: () => Float32Array;
                    set: (array: ArrayLike<number>, offset?: number) => void;
                    slice: (start?: number, end?: number) => Float32Array;
                    some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    subarray: (begin?: number, end?: number) => Float32Array;
                    toLocaleString: {
                        (): string;
                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                    };
                    toString: () => string;
                    valueOf: () => Float32Array;
                    entries: () => IterableIterator<[number, number]>;
                    keys: () => IterableIterator<number>;
                    values: () => IterableIterator<number>;
                    includes: (searchElement: number, fromIndex?: number) => boolean;
                    at: (index: number) => number | undefined;
                    findLast: {
                        <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                        (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                    };
                    findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                    toReversed: () => Float32Array;
                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    with: (index: number, value: number) => Float32Array;
                    [Symbol.iterator]: () => IterableIterator<number>;
                    readonly [Symbol.toStringTag]: "Float32Array";
                };
                ValueBufferType: {
                    [x: number]: number;
                    readonly BYTES_PER_ELEMENT: number;
                    readonly buffer: {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => ArrayBuffer;
                        readonly [Symbol.toStringTag]: string;
                    } | {
                        readonly byteLength: number;
                        slice: (begin: number, end?: number) => SharedArrayBuffer;
                        readonly [Symbol.species]: SharedArrayBuffer;
                        readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                    };
                    readonly byteLength: number;
                    readonly byteOffset: number;
                    copyWithin: (target: number, start: number, end?: number) => Float32Array;
                    every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    fill: (value: number, start?: number, end?: number) => Float32Array;
                    filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                    find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                    findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                    forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                    indexOf: (searchElement: number, fromIndex?: number) => number;
                    join: (separator?: string) => string;
                    lastIndexOf: (searchElement: number, fromIndex?: number) => number;
                    readonly length: number;
                    map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                    reduce: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reduceRight: {
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                        (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                        <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                    };
                    reverse: () => Float32Array;
                    set: (array: ArrayLike<number>, offset?: number) => void;
                    slice: (start?: number, end?: number) => Float32Array;
                    some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                    sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    subarray: (begin?: number, end?: number) => Float32Array;
                    toLocaleString: {
                        (): string;
                        (locales: string | string[], options?: Intl.NumberFormatOptions): string;
                    };
                    toString: () => string;
                    valueOf: () => Float32Array;
                    entries: () => IterableIterator<[number, number]>;
                    keys: () => IterableIterator<number>;
                    values: () => IterableIterator<number>;
                    includes: (searchElement: number, fromIndex?: number) => boolean;
                    at: (index: number) => number | undefined;
                    findLast: {
                        <S extends number>(predicate: (value: number, index: number, array: Float32Array) => value is S, thisArg?: any): S | undefined;
                        (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any): number | undefined;
                    };
                    findLastIndex: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => number;
                    toReversed: () => Float32Array;
                    toSorted: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                    with: (index: number, value: number) => Float32Array;
                    [Symbol.iterator]: () => IterableIterator<number>;
                    readonly [Symbol.toStringTag]: "Float32Array";
                };
                DefaultInterpolation: import('three').InterpolationModes;
                InterpolantFactoryMethodDiscrete: (result: any) => import('three').DiscreteInterpolant;
                InterpolantFactoryMethodLinear: (result: any) => import('three').LinearInterpolant;
                InterpolantFactoryMethodSmooth: (result: any) => import('three').CubicInterpolant;
                setInterpolation: (interpolation: import('three').InterpolationModes) => import('three').KeyframeTrack;
                getInterpolation: () => import('three').InterpolationModes;
                createInterpolant: () => import('three').Interpolant;
                getValueSize: () => number;
                shift: (timeOffset: number) => import('three').KeyframeTrack;
                scale: (timeScale: number) => import('three').KeyframeTrack;
                trim: (startTime: number, endTime: number) => import('three').KeyframeTrack;
                validate: () => boolean;
                optimize: () => import('three').KeyframeTrack;
                clone: () => import('three').KeyframeTrack;
            }[];
            blendMode: import('three').AnimationBlendMode;
            duration: number;
            uuid: string;
            results: any[];
            resetDuration: () => import('three').AnimationClip;
            trim: () => import('three').AnimationClip;
            validate: () => boolean;
            optimize: () => import('three').AnimationClip;
            clone: () => import('three').AnimationClip;
            toJSON: (clip: import('three').AnimationClip) => any;
        }[];
        userData: Record<string, any>;
        customDepthMaterial?: {
            readonly isMaterial: true;
            alphaHash: boolean;
            alphaToCoverage: boolean;
            blendAlpha: number;
            blendColor: {
                readonly isColor: true;
                r: number;
                g: number;
                b: number;
                set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                setScalar: (scalar: number) => import('three').Color;
                setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                clone: () => import('three').Color;
                copy: (color: import('three').Color) => import('three').Color;
                copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                convertSRGBToLinear: () => import('three').Color;
                convertLinearToSRGB: () => import('three').Color;
                getHex: (colorSpace?: import('three').ColorSpace) => number;
                getHexString: (colorSpace?: import('three').ColorSpace) => string;
                getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
                getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
                getStyle: (colorSpace?: import('three').ColorSpace) => string;
                offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                add: (color: import('three').Color) => import('three').Color;
                addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                addScalar: (s: number) => import('three').Color;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                sub: (color: import('three').Color) => import('three').Color;
                multiply: (color: import('three').Color) => import('three').Color;
                multiplyScalar: (s: number) => import('three').Color;
                lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                equals: (color: import('three').Color) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                toJSON: () => number;
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                [Symbol.iterator]: () => Generator<number, void>;
            };
            blendDst: import('three').BlendingDstFactor;
            blendDstAlpha: number | null;
            blendEquation: import('three').BlendingEquation;
            blendEquationAlpha: number | null;
            blending: import('three').Blending;
            blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
            blendSrcAlpha: number | null;
            clipIntersection: boolean;
            clippingPlanes: {
                normal: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number>;
                };
                constant: number;
                readonly isPlane: true;
                set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                clone: () => import('three').Plane;
                copy: (plane: import('three').Plane) => import('three').Plane;
                normalize: () => import('three').Plane;
                negate: () => import('three').Plane;
                distanceToPoint: (point: import('three').Vector3) => number;
                distanceToSphere: (sphere: import('three').Sphere) => number;
                projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                intersectsLine: (line: import('three').Line3) => boolean;
                intersectsBox: (box: import('three').Box3) => boolean;
                intersectsSphere: (sphere: import('three').Sphere) => boolean;
                coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
                translate: (offset: import('three').Vector3) => import('three').Plane;
                equals: (plane: import('three').Plane) => boolean;
                isIntersectionLine: (l: any) => any;
            }[] | null;
            clipShadows: boolean;
            colorWrite: boolean;
            defines: undefined | {
                [key: string]: any;
            };
            depthFunc: import('three').DepthModes;
            depthTest: boolean;
            depthWrite: boolean;
            id: number;
            stencilWrite: boolean;
            stencilFunc: import('three').StencilFunc;
            stencilRef: number;
            stencilWriteMask: number;
            stencilFuncMask: number;
            stencilFail: import('three').StencilOp;
            stencilZFail: import('three').StencilOp;
            stencilZPass: import('three').StencilOp;
            name: string;
            opacity: number;
            polygonOffset: boolean;
            polygonOffsetFactor: number;
            polygonOffsetUnits: number;
            precision: "highp" | "mediump" | "lowp" | null;
            premultipliedAlpha: boolean;
            forceSinglePass: boolean;
            dithering: boolean;
            side: import('three').Side;
            shadowSide: import('three').Side | null;
            toneMapped: boolean;
            transparent: boolean;
            type: string;
            uuid: string;
            vertexColors: boolean;
            visible: boolean;
            userData: Record<string, any>;
            version: number;
            alphaTest: number;
            onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
            customProgramCacheKey: () => string;
            setValues: (values: import('three').MaterialParameters) => void;
            toJSON: (meta?: any) => any;
            clone: () => import('three').Material;
            copy: (material: import('three').Material) => import('three').Material;
            dispose: () => void;
            needsUpdate: boolean;
            onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
            addEventListener: {
                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, import('three').Material>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
            };
            hasEventListener: {
                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, import('three').Material>): boolean;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
            };
            removeEventListener: {
                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, import('three').Material>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
            };
            dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                dispose: {};
            }[T]) => void;
        } | undefined;
        customDistanceMaterial?: {
            readonly isMaterial: true;
            alphaHash: boolean;
            alphaToCoverage: boolean;
            blendAlpha: number;
            blendColor: {
                readonly isColor: true;
                r: number;
                g: number;
                b: number;
                set: (...args: [color: import('three').ColorRepresentation] | [r: number, g: number, b: number]) => import('three').Color;
                setFromVector3: (vector: import('three').Vector3) => import('three').Color;
                setScalar: (scalar: number) => import('three').Color;
                setHex: (hex: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setRGB: (r: number, g: number, b: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setHSL: (h: number, s: number, l: number, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setStyle: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                setColorName: (style: string, colorSpace?: import('three').ColorSpace) => import('three').Color;
                clone: () => import('three').Color;
                copy: (color: import('three').Color) => import('three').Color;
                copySRGBToLinear: (color: import('three').Color) => import('three').Color;
                copyLinearToSRGB: (color: import('three').Color) => import('three').Color;
                convertSRGBToLinear: () => import('three').Color;
                convertLinearToSRGB: () => import('three').Color;
                getHex: (colorSpace?: import('three').ColorSpace) => number;
                getHexString: (colorSpace?: import('three').ColorSpace) => string;
                getHSL: (target: import('three').HSL, colorSpace?: import('three').ColorSpace) => import('three').HSL;
                getRGB: (target: import('three').RGB, colorSpace?: import('three').ColorSpace) => import('three').RGB;
                getStyle: (colorSpace?: import('three').ColorSpace) => string;
                offsetHSL: (h: number, s: number, l: number) => import('three').Color;
                add: (color: import('three').Color) => import('three').Color;
                addColors: (color1: import('three').Color, color2: import('three').Color) => import('three').Color;
                addScalar: (s: number) => import('three').Color;
                applyMatrix3: (m: import('three').Matrix3) => import('three').Color;
                sub: (color: import('three').Color) => import('three').Color;
                multiply: (color: import('three').Color) => import('three').Color;
                multiplyScalar: (s: number) => import('three').Color;
                lerp: (color: import('three').Color, alpha: number) => import('three').Color;
                lerpColors: (color1: import('three').Color, color2: import('three').Color, alpha: number) => import('three').Color;
                lerpHSL: (color: import('three').Color, alpha: number) => import('three').Color;
                equals: (color: import('three').Color) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Color;
                toArray: {
                    (array?: number[], offset?: number): number[];
                    (xyz: ArrayLike<number>, offset?: number): ArrayLike<number>;
                };
                toJSON: () => number;
                fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Color;
                [Symbol.iterator]: () => Generator<number, void>;
            };
            blendDst: import('three').BlendingDstFactor;
            blendDstAlpha: number | null;
            blendEquation: import('three').BlendingEquation;
            blendEquationAlpha: number | null;
            blending: import('three').Blending;
            blendSrc: import('three').BlendingSrcFactor | import('three').BlendingDstFactor;
            blendSrcAlpha: number | null;
            clipIntersection: boolean;
            clippingPlanes: {
                normal: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import('three').Vector3;
                    setScalar: (scalar: number) => import('three').Vector3;
                    setX: (x: number) => import('three').Vector3;
                    setY: (y: number) => import('three').Vector3;
                    setZ: (z: number) => import('three').Vector3;
                    setComponent: (index: number, value: number) => import('three').Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import('three').Vector3;
                    copy: (v: import('three').Vector3Like) => import('three').Vector3;
                    add: (v: import('three').Vector3Like) => import('three').Vector3;
                    addScalar: (s: number) => import('three').Vector3;
                    addVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    addScaledVector: (v: import('three').Vector3, s: number) => import('three').Vector3;
                    sub: (a: import('three').Vector3Like) => import('three').Vector3;
                    subScalar: (s: number) => import('three').Vector3;
                    subVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    multiply: (v: import('three').Vector3Like) => import('three').Vector3;
                    multiplyScalar: (s: number) => import('three').Vector3;
                    multiplyVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    applyEuler: (euler: import('three').Euler) => import('three').Vector3;
                    applyAxisAngle: (axis: import('three').Vector3, angle: number) => import('three').Vector3;
                    applyMatrix3: (m: import('three').Matrix3) => import('three').Vector3;
                    applyNormalMatrix: (m: import('three').Matrix3) => import('three').Vector3;
                    applyMatrix4: (m: import('three').Matrix4) => import('three').Vector3;
                    applyQuaternion: (q: import('three').QuaternionLike) => import('three').Vector3;
                    project: (camera: Camera) => import('three').Vector3;
                    unproject: (camera: Camera) => import('three').Vector3;
                    transformDirection: (m: import('three').Matrix4) => import('three').Vector3;
                    divide: (v: import('three').Vector3Like) => import('three').Vector3;
                    divideScalar: (s: number) => import('three').Vector3;
                    min: (v: import('three').Vector3Like) => import('three').Vector3;
                    max: (v: import('three').Vector3Like) => import('three').Vector3;
                    clamp: (min: import('three').Vector3Like, max: import('three').Vector3Like) => import('three').Vector3;
                    clampScalar: (min: number, max: number) => import('three').Vector3;
                    clampLength: (min: number, max: number) => import('three').Vector3;
                    floor: () => import('three').Vector3;
                    ceil: () => import('three').Vector3;
                    round: () => import('three').Vector3;
                    roundToZero: () => import('three').Vector3;
                    negate: () => import('three').Vector3;
                    dot: (v: import('three').Vector3Like) => number;
                    lengthSq: () => number;
                    length: () => number;
                    manhattanLength: () => number;
                    normalize: () => import('three').Vector3;
                    setLength: (l: number) => import('three').Vector3;
                    lerp: (v: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    lerpVectors: (v1: import('three').Vector3Like, v2: import('three').Vector3Like, alpha: number) => import('three').Vector3;
                    cross: (a: import('three').Vector3Like) => import('three').Vector3;
                    crossVectors: (a: import('three').Vector3Like, b: import('three').Vector3Like) => import('three').Vector3;
                    projectOnVector: (v: import('three').Vector3) => import('three').Vector3;
                    projectOnPlane: (planeNormal: import('three').Vector3) => import('three').Vector3;
                    reflect: (vector: import('three').Vector3Like) => import('three').Vector3;
                    angleTo: (v: import('three').Vector3) => number;
                    distanceTo: (v: import('three').Vector3Like) => number;
                    distanceToSquared: (v: import('three').Vector3Like) => number;
                    manhattanDistanceTo: (v: import('three').Vector3Like) => number;
                    setFromSpherical: (s: import('three').Spherical) => import('three').Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import('three').Vector3;
                    setFromCylindrical: (s: import('three').Cylindrical) => import('three').Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import('three').Vector3;
                    setFromMatrixPosition: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixScale: (m: import('three').Matrix4) => import('three').Vector3;
                    setFromMatrixColumn: (matrix: import('three').Matrix4, index: number) => import('three').Vector3;
                    setFromMatrix3Column: (matrix: import('three').Matrix3, index: number) => import('three').Vector3;
                    setFromEuler: (e: import('three').Euler) => import('three').Vector3;
                    setFromColor: (color: import('three').RGB) => import('three').Vector3;
                    equals: (v: import('three').Vector3Like) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number) => import('three').Vector3;
                    toArray: {
                        (array?: number[], offset?: number): number[];
                        (array?: import('three').Vector3Tuple, offset?: 0): import('three').Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import('three').BufferAttribute | import('three').InterleavedBufferAttribute, index: number) => import('three').Vector3;
                    random: () => import('three').Vector3;
                    randomDirection: () => import('three').Vector3;
                    [Symbol.iterator]: () => Iterator<number>;
                };
                constant: number;
                readonly isPlane: true;
                set: (normal: import('three').Vector3, constant: number) => import('three').Plane;
                setComponents: (x: number, y: number, z: number, w: number) => import('three').Plane;
                setFromNormalAndCoplanarPoint: (normal: import('three').Vector3, point: import('three').Vector3) => import('three').Plane;
                setFromCoplanarPoints: (a: import('three').Vector3, b: import('three').Vector3, c: import('three').Vector3) => import('three').Plane;
                clone: () => import('three').Plane;
                copy: (plane: import('three').Plane) => import('three').Plane;
                normalize: () => import('three').Plane;
                negate: () => import('three').Plane;
                distanceToPoint: (point: import('three').Vector3) => number;
                distanceToSphere: (sphere: import('three').Sphere) => number;
                projectPoint: (point: import('three').Vector3, target: import('three').Vector3) => import('three').Vector3;
                intersectLine: (line: import('three').Line3, target: import('three').Vector3) => import('three').Vector3 | null;
                intersectsLine: (line: import('three').Line3) => boolean;
                intersectsBox: (box: import('three').Box3) => boolean;
                intersectsSphere: (sphere: import('three').Sphere) => boolean;
                coplanarPoint: (target: import('three').Vector3) => import('three').Vector3;
                applyMatrix4: (matrix: import('three').Matrix4, optionalNormalMatrix?: import('three').Matrix3) => import('three').Plane;
                translate: (offset: import('three').Vector3) => import('three').Plane;
                equals: (plane: import('three').Plane) => boolean;
                isIntersectionLine: (l: any) => any;
            }[] | null;
            clipShadows: boolean;
            colorWrite: boolean;
            defines: undefined | {
                [key: string]: any;
            };
            depthFunc: import('three').DepthModes;
            depthTest: boolean;
            depthWrite: boolean;
            id: number;
            stencilWrite: boolean;
            stencilFunc: import('three').StencilFunc;
            stencilRef: number;
            stencilWriteMask: number;
            stencilFuncMask: number;
            stencilFail: import('three').StencilOp;
            stencilZFail: import('three').StencilOp;
            stencilZPass: import('three').StencilOp;
            name: string;
            opacity: number;
            polygonOffset: boolean;
            polygonOffsetFactor: number;
            polygonOffsetUnits: number;
            precision: "highp" | "mediump" | "lowp" | null;
            premultipliedAlpha: boolean;
            forceSinglePass: boolean;
            dithering: boolean;
            side: import('three').Side;
            shadowSide: import('three').Side | null;
            toneMapped: boolean;
            transparent: boolean;
            type: string;
            uuid: string;
            vertexColors: boolean;
            visible: boolean;
            userData: Record<string, any>;
            version: number;
            alphaTest: number;
            onBeforeCompile: (parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
            customProgramCacheKey: () => string;
            setValues: (values: import('three').MaterialParameters) => void;
            toJSON: (meta?: any) => any;
            clone: () => import('three').Material;
            copy: (material: import('three').Material) => import('three').Material;
            dispose: () => void;
            needsUpdate: boolean;
            onBuild: (object: import('three').Object3D, parameters: import('three').WebGLProgramParametersWithUniforms, renderer: import('three').WebGLRenderer) => void;
            onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, object: import('three').Object3D, group: import('three').Group) => void;
            addEventListener: {
                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, import('three').Material>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
            };
            hasEventListener: {
                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, import('three').Material>): boolean;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): boolean;
            };
            removeEventListener: {
                <T extends "dispose">(type: T, listener: import('three').EventListener<{
                    dispose: {};
                }[T], T, import('three').Material>): void;
                <T extends string>(type: T, listener: import('three').EventListener<{}, T, import('three').Material>): void;
            };
            dispatchEvent: <T extends "dispose">(event: import('three').BaseEvent<T> & {
                dispose: {};
            }[T]) => void;
        } | undefined;
        onBeforeShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
        onAfterShadow: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, shadowCamera: Camera, geometry: import('three').BufferGeometry, depthMaterial: import('three').Material, group: import('three').Group) => void;
        onBeforeRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
        onAfterRender: (renderer: import('three').WebGLRenderer, scene: import('three').Scene, camera: Camera, geometry: import('three').BufferGeometry, material: import('three').Material, group: import('three').Group) => void;
        applyMatrix4: (matrix: import('three').Matrix4) => void;
        applyQuaternion: (quaternion: import('three').Quaternion) => Camera;
        setRotationFromAxisAngle: (axis: import('three').Vector3, angle: number) => void;
        setRotationFromEuler: (euler: import('three').Euler) => void;
        setRotationFromMatrix: (m: import('three').Matrix4) => void;
        setRotationFromQuaternion: (q: import('three').Quaternion) => void;
        rotateOnAxis: (axis: import('three').Vector3, angle: number) => Camera;
        rotateOnWorldAxis: (axis: import('three').Vector3, angle: number) => Camera;
        rotateX: (angle: number) => Camera;
        rotateY: (angle: number) => Camera;
        rotateZ: (angle: number) => Camera;
        translateOnAxis: (axis: import('three').Vector3, distance: number) => Camera;
        translateX: (distance: number) => Camera;
        translateY: (distance: number) => Camera;
        translateZ: (distance: number) => Camera;
        localToWorld: (vector: import('three').Vector3) => import('three').Vector3;
        worldToLocal: (vector: import('three').Vector3) => import('three').Vector3;
        lookAt: {
            (vector: import('three').Vector3): void;
            (x: number, y: number, z: number): void;
        };
        add: (...object: import('three').Object3D[]) => Camera;
        remove: (...object: import('three').Object3D[]) => Camera;
        removeFromParent: () => Camera;
        clear: () => Camera;
        attach: (object: import('three').Object3D) => Camera;
        getObjectById: (id: number) => import('three').Object3D | undefined;
        getObjectByName: (name: string) => import('three').Object3D | undefined;
        getObjectByProperty: (name: string, value: any) => import('three').Object3D | undefined;
        getObjectsByProperty: (name: string, value: any, optionalTarget?: import('three').Object3D[]) => import('three').Object3D[];
        getWorldPosition: (target: import('three').Vector3) => import('three').Vector3;
        getWorldQuaternion: (target: import('three').Quaternion) => import('three').Quaternion;
        getWorldScale: (target: import('three').Vector3) => import('three').Vector3;
        raycast: (raycaster: import('three').Raycaster, intersects: import('three').Intersection[]) => void;
        traverse: (callback: (object: import('three').Object3D) => any) => void;
        traverseVisible: (callback: (object: import('three').Object3D) => any) => void;
        traverseAncestors: (callback: (object: import('three').Object3D) => any) => void;
        updateMatrix: () => void;
        updateMatrixWorld: (force?: boolean) => void;
        updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
        toJSON: (meta?: {
            geometries: any;
            materials: any;
            textures: any;
            images: any;
        }) => any;
        clone: (recursive?: boolean) => Camera;
        copy: (object: import('three').Object3D, recursive?: boolean) => Camera;
        addEventListener: {
            <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, Camera>): void;
            <T extends string>(type: T, listener: import('three').EventListener<{}, T, Camera>): void;
        };
        hasEventListener: {
            <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, Camera>): boolean;
            <T extends string>(type: T, listener: import('three').EventListener<{}, T, Camera>): boolean;
        };
        removeEventListener: {
            <T extends keyof import('three').Object3DEventMap>(type: T, listener: import('three').EventListener<import('three').Object3DEventMap[T], T, Camera>): void;
            <T extends string>(type: T, listener: import('three').EventListener<{}, T, Camera>): void;
        };
        dispatchEvent: <T extends keyof import('three').Object3DEventMap>(event: import('three').BaseEvent<T> & import('three').Object3DEventMap[T]) => void;
    }[]>;
    registerCamera: (maybeCamera: unknown, active?: boolean) => void;
    deregisterCamera: (maybeCamera: unknown) => void;
    setCameraActive: (cameraOrUuid: string | Camera) => void;
};
